fn main() {
    let  original: [[i32; 13]; 13] = [[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                                      [ 0, 0, 0, 0, 0,21, 0, 0, 0, 0, 0,27, 0],
                                      [ 0, 0,24, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0],
                                      [ 3, 0, 0, 0, 0, 0, 0, 0,24, 0, 0, 0, 0],
                                      [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,28],
                                      [ 0, 3, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0],
                                      [ 0, 0, 0, 0, 8, 0, 0, 0, 5, 0, 0, 0, 0],
                                      [ 0, 0, 0, 0, 0,30, 0, 0, 0, 0, 0, 2, 0],
                                      [24, 0 ,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                                      [ 0, 0, 0, 0,16, 0, 0, 0, 0, 0, 0, 0, 2],
                                      [ 0, 0, 0, 0, 0, 0,24, 0, 0, 0,70, 0, 0],
                                      [ 0, 8, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0],
                                      [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    ];

    // let  shaded: [[i32; 13]; 13] =   [[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    //                                   [ 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    //                                   [ 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0],
    //                                   [ 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0],
    //                                   [ 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],
    //                                   [ 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
    //                                   [ 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0],
    //                                   [ 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
    //                                   [ 1, 0 ,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    //                                   [ 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1],
    //                                   [ 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0],
    //                                   [ 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
    //                                   [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    // ];

    let  shaded: [[i32; 13]; 13] =   [[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                                      [ 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
                                      [ 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
                                      [ 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
                                      [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                                      [ 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0],
                                      [ 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0],
                                      [ 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0],
                                      [ 1, 0 ,0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
                                      [ 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1],
                                      [ 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0],
                                      [ 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0],
                                      [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]
    ];

    let mut grid = Grid{ grid: original };
    grid.print();


    let mut grid = Grid{ grid: shaded };
    grid.print();

    grid.transpose();
    grid.print();

    grid.swap_cols();
    grid.print();

}

#[derive(Debug)] 
struct Grid {
    grid: [[i32; 13]; 13],
}

impl Grid {
    fn print(&self) {
        for i in 0..self.grid.len() {
            for j in 0..self.grid.len() {
                let val = self.grid[i][j];
                if val == 0 {
                    print!(" . ")
                } else if val == 1 {
                    print!(" # ")
                } else {
                    if val > 9 {
                        print!("{:?} ", self.grid[i][j]);
                    } else {
                        print!(" {:?} ", self.grid[i][j]);
                    }
                }
            }
            print!("\n");
        }
        println!("");
    }

    fn transpose(&mut self) {
        for i in 0..self.grid.len() {
            for j in i..self.grid.len() {
                let temp = self.grid[i][j];
                self.grid[i][j] = self.grid[j][i];
                self.grid[j][i] = temp;
            }
        }
    }

    fn swap_cols(&mut self) {
        for i in 0..self.grid.len()/2 {
            for j in 0..self.grid[i].len() {
                let temp = self.grid[j][i];
                self.grid[j][i] = self.grid[j][self.grid.len() - i - 1];
                self.grid[j][self.grid.len() - i - 1] = temp;
            }
        }
    }
}


/*
unique values
 2: {2,1,1,1}
 3: {3,1,1,1}
 5: {5,1,1,1}
 6: {6,1,1,1}, {3,2,1,1}
 8: {2,2,2,1}, {4,2,1,1}, {8,1,1,1}
16: {2,2,2,2}, {4,4,1,1}, {4,2,2,1}, {8,2,1,1}
21: {7,3,1,1}
24: {12,2,1,1}, {8,3,1,1}, {6,4,1,1}, {6,2,2,1}, {4,3,2,1}, {3,2,2,2}
27: {9,3,1,1}, {3,3,3,1}
28: {7,4,1,1}, {7,2,2,1}
30: {6,5,1,1}, {5,3,2,1}
70: {7,5,2,1}

 2: 4
 3: 4
 5: 4
 6: 8
 8: 12
16: 12
21: 4
24: 24
27: 8
28: 8
30: 8
70: 4
//[4,4,4,8,12,12,4,24,8,8,8,4]

let mut array: [[i32; 13]; 13] = [[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                                      [ 0, 0, 0, 0, 0,21, 0, 0, 0, 0, 0,27, 0],
                                      [ 0, 0,24, 0 ,0 ,0, 8, 0, 0, 0, 0, 0, 0],
                                      [ 3, 0, 0, 0, 0, 0, 0, 0,24, 0, 0, 0, 0],
                                      [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,28],
                                      [ 0, 3, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0],
                                      [ 0, 0, 0, 0, 8, 0, 0, 0, 5, 0, 0, 0, 0],
                                      [ 0, 0, 0, 0, 0,30, 0, 0, 0, 0, 0, 2, 0],
                                      [24 ,0 ,0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0],
                                      [ 0, 0, 0, 0,16 ,0, 0, 0, 0, 0, 0, 0, 2],
                                      [ 0, 0, 0, 0, 0, 0, 0,24, 0, 0,70, 0, 0],
                                      [ 0, 8, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0],
                                      [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    ];
*/


